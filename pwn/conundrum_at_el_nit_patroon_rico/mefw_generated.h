// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MEFW_ME_H_
#define FLATBUFFERS_GENERATED_MEFW_ME_H_

#include "flatbuffers/flatbuffers.h"

namespace me {

struct Chunk;
struct ChunkBuilder;

struct File;
struct FileBuilder;

struct FwHeader;
struct FwHeaderBuilder;

struct Chunk FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChunkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct ChunkBuilder {
  typedef Chunk Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Chunk::VT_DATA, data);
  }
  explicit ChunkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Chunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Chunk>(end);
    return o;
  }
};

inline flatbuffers::Offset<Chunk> CreateChunk(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  ChunkBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Chunk> CreateChunkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return me::CreateChunk(
      _fbb,
      data__);
}

struct File FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TOTALSIZE = 6,
    VT_SIGNED_ = 8,
    VT_CHUNKS = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint64_t totalSize() const {
    return GetField<uint64_t>(VT_TOTALSIZE, 0);
  }
  bool signed_() const {
    return GetField<uint8_t>(VT_SIGNED_, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<me::Chunk>> *chunks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<me::Chunk>> *>(VT_CHUNKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_TOTALSIZE) &&
           VerifyField<uint8_t>(verifier, VT_SIGNED_) &&
           VerifyOffset(verifier, VT_CHUNKS) &&
           verifier.VerifyVector(chunks()) &&
           verifier.VerifyVectorOfTables(chunks()) &&
           verifier.EndTable();
  }
};

struct FileBuilder {
  typedef File Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(File::VT_NAME, name);
  }
  void add_totalSize(uint64_t totalSize) {
    fbb_.AddElement<uint64_t>(File::VT_TOTALSIZE, totalSize, 0);
  }
  void add_signed_(bool signed_) {
    fbb_.AddElement<uint8_t>(File::VT_SIGNED_, static_cast<uint8_t>(signed_), 0);
  }
  void add_chunks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<me::Chunk>>> chunks) {
    fbb_.AddOffset(File::VT_CHUNKS, chunks);
  }
  explicit FileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<File> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<File>(end);
    return o;
  }
};

inline flatbuffers::Offset<File> CreateFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint64_t totalSize = 0,
    bool signed_ = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<me::Chunk>>> chunks = 0) {
  FileBuilder builder_(_fbb);
  builder_.add_totalSize(totalSize);
  builder_.add_chunks(chunks);
  builder_.add_name(name);
  builder_.add_signed_(signed_);
  return builder_.Finish();
}

inline flatbuffers::Offset<File> CreateFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t totalSize = 0,
    bool signed_ = false,
    const std::vector<flatbuffers::Offset<me::Chunk>> *chunks = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto chunks__ = chunks ? _fbb.CreateVector<flatbuffers::Offset<me::Chunk>>(*chunks) : 0;
  return me::CreateFile(
      _fbb,
      name__,
      totalSize,
      signed_,
      chunks__);
}

struct FwHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FwHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FWVERMAJOR = 4,
    VT_FWVERMINOR = 6,
    VT_FWVERSUBMINOR = 8,
    VT_FILES = 10,
    VT_LOFASZ1 = 12,
    VT_LOFASZ2 = 14,
    VT_LOFASZ3 = 16,
    VT_LOFASZ4 = 18,
    VT_LOFASZ5 = 20,
    VT_LOFASZ6 = 22
  };
  int16_t fwVerMajor() const {
    return GetField<int16_t>(VT_FWVERMAJOR, 1);
  }
  int16_t fwVerMinor() const {
    return GetField<int16_t>(VT_FWVERMINOR, 1);
  }
  int16_t fwVerSubminor() const {
    return GetField<int16_t>(VT_FWVERSUBMINOR, 1);
  }
  const flatbuffers::Vector<flatbuffers::Offset<me::File>> *files() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<me::File>> *>(VT_FILES);
  }
  uint64_t lofasz1() const {
    return GetField<uint64_t>(VT_LOFASZ1, 34952ULL);
  }
  uint64_t lofasz2() const {
    return GetField<uint64_t>(VT_LOFASZ2, 34952ULL);
  }
  uint64_t lofasz3() const {
    return GetField<uint64_t>(VT_LOFASZ3, 34952ULL);
  }
  uint64_t lofasz4() const {
    return GetField<uint64_t>(VT_LOFASZ4, 34952ULL);
  }
  uint64_t lofasz5() const {
    return GetField<uint64_t>(VT_LOFASZ5, 34952ULL);
  }
  uint64_t lofasz6() const {
    return GetField<uint64_t>(VT_LOFASZ6, 34952ULL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FWVERMAJOR) &&
           VerifyField<int16_t>(verifier, VT_FWVERMINOR) &&
           VerifyField<int16_t>(verifier, VT_FWVERSUBMINOR) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfTables(files()) &&
           VerifyField<uint64_t>(verifier, VT_LOFASZ1) &&
           VerifyField<uint64_t>(verifier, VT_LOFASZ2) &&
           VerifyField<uint64_t>(verifier, VT_LOFASZ3) &&
           VerifyField<uint64_t>(verifier, VT_LOFASZ4) &&
           VerifyField<uint64_t>(verifier, VT_LOFASZ5) &&
           VerifyField<uint64_t>(verifier, VT_LOFASZ6) &&
           verifier.EndTable();
  }
};

struct FwHeaderBuilder {
  typedef FwHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fwVerMajor(int16_t fwVerMajor) {
    fbb_.AddElement<int16_t>(FwHeader::VT_FWVERMAJOR, fwVerMajor, 1);
  }
  void add_fwVerMinor(int16_t fwVerMinor) {
    fbb_.AddElement<int16_t>(FwHeader::VT_FWVERMINOR, fwVerMinor, 1);
  }
  void add_fwVerSubminor(int16_t fwVerSubminor) {
    fbb_.AddElement<int16_t>(FwHeader::VT_FWVERSUBMINOR, fwVerSubminor, 1);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<me::File>>> files) {
    fbb_.AddOffset(FwHeader::VT_FILES, files);
  }
  void add_lofasz1(uint64_t lofasz1) {
    fbb_.AddElement<uint64_t>(FwHeader::VT_LOFASZ1, lofasz1, 34952ULL);
  }
  void add_lofasz2(uint64_t lofasz2) {
    fbb_.AddElement<uint64_t>(FwHeader::VT_LOFASZ2, lofasz2, 34952ULL);
  }
  void add_lofasz3(uint64_t lofasz3) {
    fbb_.AddElement<uint64_t>(FwHeader::VT_LOFASZ3, lofasz3, 34952ULL);
  }
  void add_lofasz4(uint64_t lofasz4) {
    fbb_.AddElement<uint64_t>(FwHeader::VT_LOFASZ4, lofasz4, 34952ULL);
  }
  void add_lofasz5(uint64_t lofasz5) {
    fbb_.AddElement<uint64_t>(FwHeader::VT_LOFASZ5, lofasz5, 34952ULL);
  }
  void add_lofasz6(uint64_t lofasz6) {
    fbb_.AddElement<uint64_t>(FwHeader::VT_LOFASZ6, lofasz6, 34952ULL);
  }
  explicit FwHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FwHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FwHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<FwHeader> CreateFwHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t fwVerMajor = 1,
    int16_t fwVerMinor = 1,
    int16_t fwVerSubminor = 1,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<me::File>>> files = 0,
    uint64_t lofasz1 = 34952ULL,
    uint64_t lofasz2 = 34952ULL,
    uint64_t lofasz3 = 34952ULL,
    uint64_t lofasz4 = 34952ULL,
    uint64_t lofasz5 = 34952ULL,
    uint64_t lofasz6 = 34952ULL) {
  FwHeaderBuilder builder_(_fbb);
  builder_.add_lofasz6(lofasz6);
  builder_.add_lofasz5(lofasz5);
  builder_.add_lofasz4(lofasz4);
  builder_.add_lofasz3(lofasz3);
  builder_.add_lofasz2(lofasz2);
  builder_.add_lofasz1(lofasz1);
  builder_.add_files(files);
  builder_.add_fwVerSubminor(fwVerSubminor);
  builder_.add_fwVerMinor(fwVerMinor);
  builder_.add_fwVerMajor(fwVerMajor);
  return builder_.Finish();
}

inline flatbuffers::Offset<FwHeader> CreateFwHeaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t fwVerMajor = 1,
    int16_t fwVerMinor = 1,
    int16_t fwVerSubminor = 1,
    const std::vector<flatbuffers::Offset<me::File>> *files = nullptr,
    uint64_t lofasz1 = 34952ULL,
    uint64_t lofasz2 = 34952ULL,
    uint64_t lofasz3 = 34952ULL,
    uint64_t lofasz4 = 34952ULL,
    uint64_t lofasz5 = 34952ULL,
    uint64_t lofasz6 = 34952ULL) {
  auto files__ = files ? _fbb.CreateVector<flatbuffers::Offset<me::File>>(*files) : 0;
  return me::CreateFwHeader(
      _fbb,
      fwVerMajor,
      fwVerMinor,
      fwVerSubminor,
      files__,
      lofasz1,
      lofasz2,
      lofasz3,
      lofasz4,
      lofasz5,
      lofasz6);
}

inline const me::FwHeader *GetFwHeader(const void *buf) {
  return flatbuffers::GetRoot<me::FwHeader>(buf);
}

inline const me::FwHeader *GetSizePrefixedFwHeader(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<me::FwHeader>(buf);
}

inline const char *FwHeaderIdentifier() {
  return "MEFW";
}

inline bool FwHeaderBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, FwHeaderIdentifier());
}

inline bool VerifyFwHeaderBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<me::FwHeader>(FwHeaderIdentifier());
}

inline bool VerifySizePrefixedFwHeaderBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<me::FwHeader>(FwHeaderIdentifier());
}

inline void FinishFwHeaderBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<me::FwHeader> root) {
  fbb.Finish(root, FwHeaderIdentifier());
}

inline void FinishSizePrefixedFwHeaderBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<me::FwHeader> root) {
  fbb.FinishSizePrefixed(root, FwHeaderIdentifier());
}

}  // namespace me

#endif  // FLATBUFFERS_GENERATED_MEFW_ME_H_
