from z3 import *


def solve():
    p0 = find_pass([
        0x00000016, 0x0000000f, 0x00000008, 0x00000008, 0x00000004,
        0x00000006, 0x00000003, 0x00000007, 0x00000008, 0x00000004,
        0x00000005, 0x00000003, 0x00000004, 0x00000006, 0x00000007,
        0x00000003, 0x00000004, 0x00000003, 0x00000003, 0x00000004,
        0x00000003, 0x00000002, 0x00000006, 0x00000005, 0x00000003
    ])

    p1 = find_pass([
        0x00000014, 0x0000000a, 0x00000006, 0x00000007, 0x00000004,
        0x00000003, 0x00000003, 0x0000000a, 0x00000008, 0x00000007,
        0x00000006, 0x00000004, 0x00000004, 0x00000006, 0x00000003,
        0x00000002, 0x00000003, 0x00000002, 0x00000003, 0x00000003,
        0x00000004, 0x00000004, 0x00000005, 0x00000004, 0x00000002
    ])

    p2 = find_pass([
        0x00000018, 0x0000000e, 0x00000009, 0x00000008, 0x00000007,
        0x00000006, 0x00000003, 0x0000000a, 0x0000000a, 0x00000006,
        0x00000006, 0x00000005, 0x00000005, 0x00000005, 0x00000006,
        0x00000002, 0x00000003, 0x00000002, 0x00000004, 0x00000005,
        0x00000004, 0x00000004, 0x00000004, 0x00000005, 0x00000003
    ])

    p3 = find_pass([
        0x0000000d, 0x00000007, 0x00000005, 0x00000005, 0x00000003,
        0x00000003, 0x00000002, 0x00000006, 0x00000004, 0x00000005,
        0x00000003, 0x00000002, 0x00000003, 0x00000004, 0x00000002,
        0x00000002, 0x00000002, 0x00000003, 0x00000001, 0x00000002,
        0x00000003, 0x00000002, 0x00000003, 0x00000002, 0x00000001
    ])

    p4 = find_pass([
        0x0000000f, 0x00000009, 0x00000006, 0x00000005, 0x00000004,
        0x00000004, 0x00000002, 0x00000006, 0x00000005, 0x00000002,
        0x00000004, 0x00000001, 0x00000004, 0x00000004, 0x00000004,
        0x00000002, 0x00000001, 0x00000003, 0x00000004, 0x00000003,
        0x00000003, 0x00000000, 0x00000002, 0x00000004, 0x00000003
    ])

    serial = '-'.join([p0, p1, p2, p3, p4])

    return 'cd21{' + serial + '}'


def find_pass(expected):
    s = Solver()

    # find a 64 number N such that
    # for each (mask, e) in zip(masks, expexted):
    #   e is the number of set bits in N & mask

    bits = []
    for bit in range(64):
        b = Int(f'bit{bit}')
        s.add(And(0 <= b, b <= 1))
        bits.append(b)

    masks = [
        0xffffffff, 0xaaaaaaaa, 0x92492492, 0x88888888, 0x84210842,
        0x82082082, 0x81020408, 0x55555555, 0x49249249, 0x44444444,
        0x42108421, 0x41041041, 0x40810204, 0x24924924, 0x22222222,
        0x21084210, 0x20820820, 0x20408102, 0x11111111, 0x10842108,
        0x10410418, 0x10204081, 0x08421084, 0x08208208, 0x08102040
    ]

    for mask, e in zip(masks, expected):
        selected_bits = []
        for i in range(64):
            if mask & (1 << i) != 0:
                selected_bits.append(bits[i])

        s.add(Sum(selected_bits) == e)

    s.check()
    res = 0
    for i in range(64):
        if s.model()[bits[i]] == 1:
            res += (1 << i)

    return hex(res)[2:].upper()


if __name__ == "__main__":
    print(solve())
